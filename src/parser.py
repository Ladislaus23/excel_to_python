# src/parser.py

"""
Модуль parser:
- process_sheet_names(all_sheets: dict) -> list[str]
    Экранирует и при необходимости берёт в кавычки имена листов.
- extract_cell_references(formula: str, all_sheets: dict) -> list[str]
    Извлекает ссылки на ячейки (диапазоны, столбцы, одиночные) из формулы.
"""

import re

def process_sheet_names(all_sheets: dict) -> list:
    """
    Экранирует имена листов для регулярного выражения.
    Если имя содержит спецсимволы или пробелы, оборачивает в одинарные кавычки.
    """
    processed = [] # Список для хранения обработанных имен листов
    for sheet in all_sheets.keys(): # Проходим по всем листам в all_sheets
        # экранируем все специальные символы с помощью re.escape
        esc = re.escape(sheet)
        # если после экранирования что-то изменилось или есть пробел — берём в кавычки
        if esc != sheet or ' ' in sheet:
            processed.append(f"'{esc}'") # Если имя листа содержит спецсимволы или пробелы, оборачиваем в кавычки
        else:
            processed.append(sheet) # Иначе, оставляем как есть
    return processed # Возвращаем список обработанных имен листов

def extract_cell_references(formula: str, all_sheets: dict) -> list:
    """
    Извлекает ссылки на ячейки/диапазоны из формулы:
     - одиночные ячейки A1, $A$1
     - диапазоны A1:B2, $A$1:$B$2
     - диапазоны столбцов A:A, $AA:$BB
     - межлистовые: Sheet1!A1, 'My Sheet'!B2:C3
    Возвращает уникальные адреса без символов '$'.
    Убирает знак '=' в начале формулы перед разбором.
    """
    
    formula = formula.lstrip('=')  # Убираем знак "=" в начале формулы, если он есть

    # 1) Базовые шаблоны для ячеек и диапазонов
    cell_ref   = r"\$?[A-Za-z]+\$?\d+"       # Одиночная ячейка, например, A1 или $A$1
    cell_range = rf"{cell_ref}:{cell_ref}"   # Диапазон ячеек, например, A1:B2 или $A$1:$B$2
    col_range  = r"\$?[A-Za-z]+:\$?[A-Za-z]+"# Диапазон столбцов, например, A:A или $AA:$BB
    row_range  = r"\$?\d+:\$?\d+"      # Диапазон строк, например, 1:1 или $2:$5


    # 2) Префикс листа: либо 'Имя Листа'!, либо bare ИмяЛиста!
    #    Здесь мы не смотрим на all_sheets — это просто синтаксис
    sheet_prefix = r"(?:'[^']+'|[^!'\s\(\),]+)!" # Соответствует имени листа (с учётом кавычек и специальных символов)

    # 3) Собираем финальный шаблон, который будет искать все нужные ссылки в формуле
    full_pattern = rf"""
        (?:                                        # — с префиксом листа:
            {sheet_prefix}
            (?:{cell_range}|{col_range}|{row_range}|{cell_ref}) # Совпадение для диапазонов и одиночных ячеек
        )
        |                                          # — ИЛИ без листа:
        (?:
            {col_range}                            # диапазон столбцов
          | {cell_range}                          # диапазон ячеек
          | {row_range}                           # диапазон строк
          | {cell_ref}                            # одиночная ячейка
        )
    """

    # Компилируем регулярное выражение с флагом re.VERBOSE, чтобы можно было писать многострочные шаблоны с комментариями
    regex = re.compile(full_pattern, re.VERBOSE)

    # 4) Ищем все совпадения в тексте формулы с использованием регулярного выражения
    matches = regex.findall(formula)

    # 5) Убираем дубликаты и удаляем символы '$' и кавычки из найденных совпадений
    unique = {m.replace('$', '').replace("'", "") for m in matches} # Используем set для удаления дубликатов
    return list(unique) # Возвращаем уникальные значения как список
