# tests/test_parser.py

import pytest
import random
import re
from src.parser import extract_cell_references

@pytest.fixture(scope="session")
def all_formulas(sheets):

    """
    Фикстура для сбора всех формул с листа 'Вход' один раз за сессию.
    Эти формулы затем передаются в тесты для проверки.
    """

    assert 'Вход' in sheets, "Лист 'Вход' не найден в all_sheets" # Проверяем, что лист 'Вход' существует
    formulas = sheets['Вход']['formulas'] # Получаем все формулы с листа 'Вход'
    print(f"[test_parser] Всего формул на листе 'Вход': {len(formulas)}") # Выводим количество формул
    return formulas # Возвращаем формулы для использования в тестах

def test_formulas_exist(all_formulas):
    """Тест для проверки, что на листе 'Вход' есть хотя бы одна формула."""
    assert all_formulas, "Формулы на листе 'Вход' отсутствуют" # Убедимся, что формулы существуют

def test_extract_dependencies_from_sample(all_formulas, sheets):
    """
    Тест для проверки извлечения зависимостей из формул.
    Проверяем:
    1) возвращает ли функция list непустых ссылок,
    2) убирает ли знаки '$' из ссылок,
    3) не дублируются ли ссылки,
    4) соответствует ли каждая ссылка шаблону Excel-адреса.
    """

    sample = random.sample(list(all_formulas.items()), min(5, len(all_formulas))) # Выбираем случайные 5 формул

    # Шаблон для проверки формата Excel-ссылки
    cell_ref_pattern = re.compile(r"""
        ^                                   # начало строки
        (?:                                 # опциональный префикс листа
            '[^']+'!                        #   либо 'Лист 2'!
          | [^!'"]+!                        #   либо любое имя, не содержащее ! или кавычек
        )?
        (?:                                 # сам адрес или диапазон
             \$?[A-Za-z]+\$?\d+            #   A1 или $A$1
           (?: :\$?[A-Za-z]+\$?\d+ )?      #   необязательно :B2 или :$B$2
         | \$?[A-Za-z]+ : \$?[A-Za-z]+     #   диапазон столбцов A:A
        )
        $                                   # конец строки
    """, re.VERBOSE)

    for addr, formula in sample:
        refs = extract_cell_references(formula, sheets) # Извлекаем зависимости из формулы
        print(f"\n[test_parser] {addr}: {formula}\n  -> refs: {refs}") # Выводим результаты для анализа

        # 1. Проверяем, что результат — это список
        assert isinstance(refs, list), f"Ожидался list, получен {type(refs)}"

        # 2. Проверяем, что список зависимостей не пустой
        assert refs, f"Пустой список зависимостей для {addr}"

        # 3. Проверяем, что нет дублирования в зависимостях
        assert len(refs) == len(set(refs)), f"Есть дубли в ссылках для {addr}: {refs}"

        # 4. Проверяем, что знаки '$' удалены из ссылок
        assert all('$' not in ref for ref in refs), f"Есть $ в ссылках для {addr}: {refs}"

        # 5. Проверяем, что каждая ссылка соответствует шаблону Excel-адреса
        for ref in refs:
            assert cell_ref_pattern.match(ref), f"Неправильный формат ссылки {ref} из {addr}"


def test_roundtrip_simple_examples(sheets):

    """
    Тест для проверки корректности работы с простыми примерами формул.
    Проверяем, что парсер правильно извлекает ячейки из формул и возвращает правильный список.
    """

    cases = {
        # --- одиночные ячейки
        "=A1":                           {"A1"}, # Ожидаем, что из формулы "=A1" извлечём {"A1"}
        "=$B$2":                         {"B2"}, # Ожидаем, что из формулы "=$B$2" извлечём {"B2"},
        # --- несколько аргументов
        "=SUM(A1,B2,$C$3)":              {"A1", "B2", "C3"}, # Ожидаем извлечение ячеек из формулы с несколькими ссылками
        
        # --- диапазоны ячеек
        "=A1:B2":                        {"A1:B2"}, # Ожидаем извлечение диапазона ячеек
        "=$A$1:$C$5":                    {"A1:C5"}, # Ожидаем извлечение диапазона столбцов и строк
        "=SUM($D$4:E6)":                 {"D4:E6"}, # Ожидаем извлечение диапазона из формулы с функцией SUM
        
        # --- диапазоны столбцов
        "=A:A":                          {"A:A"}, # Ожидаем извлечение диапазона столбцов
        "=$B:$D":                        {"B:D"}, # Ожидаем извлечение диапазона столбцов
        "=SUM(A:A,B:B)":                 {"A:A", "B:B"}, # Ожидаем извлечение двух диапазонов столбцов
        
        # --- диапазоны строк
        "=1:1":                          {"1:1"}, # Ожидаем извлечение диапазона строк
        "=2:5":                          {"2:5"}, # Ожидаем извлечение диапазона строк
        
        # --- ссылки с листами
        "=Sheet1!A1":                    {"Sheet1!A1"}, # Межлистовая ссылка
        "='My Sheet'!$B$2:$C$3":         {"My Sheet!B2:C3"}, # Межлистовая ссылка с диапазоном
        "=SUM(Sheet1!A1,'My Sheet'!B:B)":{"Sheet1!A1", "My Sheet!B:B"}, # Смешанная ссылка на несколько листов
        
        # --- смешанные (частично абсолютные)
        "=$A1:B$2":                      {"A1:B2"}, # Смешанный диапазон
        "=C$3:$D4":                      {"C3:D4"}, # Смешанный диапазон
        
        # --- вложенные функции
        "=IF(A1>0, SUM(B1:B10), AVERAGE(C1,C2))":
                                         {"A1", "B1:B10", "C1", "C2"}, # Вложенные функции с несколькими ссылками
        
        # --- 3D-ссылки (расширение «лист1:лист3!A1»)
        "=SUM(Sheet1:Sheet3!A1:A5)":     {"Sheet1:Sheet3!A1:A5"}, # 3D-ссылки с диапазоном по нескольким листам
        
        # --- синтетические, чтоб тест «не задавился»
        "=MAX(Sheet1!$C$3:D4)":          {"Sheet1!C3:D4"}, # Проверка на смешанные абсолютные и относительные ссылки
        "=IF(A:A>0,'Вход'!B1,Лист2!C3)": {"A:A", "Вход!B1", "Лист2!C3"}, # Сложные формулы с несколькими ссылками
    }
    
    for formula, expected in cases.items():
        refs = set(extract_cell_references(formula, sheets)) # Извлекаем ячейки из формулы
        print(f"[test_parser] static: {formula} -> {refs}") # Выводим извлеченные ссылки для проверки
        assert refs == expected, f"Для {formula} ожидали {expected}, получили {refs}" # Сравниваем с ожидаемым результатом
